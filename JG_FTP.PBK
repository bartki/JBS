CREATE OR REPLACE PACKAGE BODY jg_ftp AS
------------------------------------------------------------------------------------------------------------------------
    g_reply                         t_string_table := t_string_table ();
    g_binary                        BOOLEAN := TRUE;
    g_debug                         BOOLEAN := TRUE;
    g_convert_crlf                  BOOLEAN := TRUE;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE DEBUG (
        p_text                          IN      VARCHAR2);

------------------------------------------------------------------------------------------------------------------------
    FUNCTION Login (
        p_host                          IN      VARCHAR2,
        p_port                          IN      VARCHAR2,
        p_user                          IN      VARCHAR2,
        p_pass                          IN      VARCHAR2,
        p_timeout                       IN      NUMBER := NULL)
        RETURN UTL_TCP.connection IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
    BEGIN
        g_reply.DELETE;
        l_conn  := UTL_TCP.open_connection (p_host, p_port, tx_timeout => p_timeout);
        get_reply (l_conn);
        send_command (l_conn, 'USER ' || p_user);
        send_command (l_conn, 'PASS ' || p_pass);
        RETURN l_conn;
    END;

------------------------------------------------------------------------------------------------------------------------
    FUNCTION Get_Passive (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection)
        RETURN UTL_TCP.connection IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_reply                         VARCHAR2 (32767);
        --l_host    VARCHAR(100);
        l_port1                         NUMBER (10);
        l_port2                         NUMBER (10);
    BEGIN
        send_command (p_conn, 'PASV');
        l_reply  := g_reply (g_reply.LAST);
        l_reply  :=
            REPLACE (SUBSTR (l_reply, INSTR (l_reply, '(') + 1, (INSTR (l_reply, ')')) - (INSTR (l_reply, '(')) - 1),
                     ',',
                     '.');
        --l_host  := SUBSTR(l_reply, 1, INSTR(l_reply, '.', 1, 4)-1);
        l_port1  :=
            TO_NUMBER (SUBSTR (l_reply,
                               INSTR (l_reply, '.', 1, 4) + 1,
                               (INSTR (l_reply, '.', 1, 5) - 1) - (INSTR (l_reply, '.', 1, 4))));
        l_port2  := TO_NUMBER (SUBSTR (l_reply, INSTR (l_reply, '.', 1, 5) + 1));
        --l_conn := utl_tcp.open_connection(l_host, 256 * l_port1 + l_port2);
        l_conn   := UTL_TCP.open_connection (p_conn.remote_host, 256 * l_port1 + l_port2);
        RETURN l_conn;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE LOGOUT (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_reply                         IN      BOOLEAN := TRUE) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        send_command (p_conn, 'QUIT', p_reply);
        UTL_TCP.close_connection (p_conn);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Send_Command (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_command                       IN      VARCHAR2,
        p_reply                         IN      BOOLEAN := TRUE) IS
------------------------------------------------------------------------------------------------------------------------
        l_result                        PLS_INTEGER;
    BEGIN
        l_result  := UTL_TCP.write_line (p_conn, p_command);

        -- If you get ORA-29260 after the PASV call, replace the above line with the following line.
        -- l_result := UTL_TCP.write_text(p_conn, p_command || utl_tcp.crlf, length(p_command || utl_tcp.crlf));
        IF p_reply
        THEN
            get_reply (p_conn);
        END IF;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Get_Reply (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection) IS
------------------------------------------------------------------------------------------------------------------------
        l_reply_code                    VARCHAR2 (3) := NULL;
    BEGIN
        LOOP
            g_reply.EXTEND;
            g_reply (g_reply.LAST)  := UTL_TCP.get_line (p_conn, TRUE);
            DEBUG (g_reply (g_reply.LAST));

            IF l_reply_code IS NULL
            THEN
                l_reply_code  := SUBSTR (g_reply (g_reply.LAST), 1, 3);
            END IF;

            IF SUBSTR (l_reply_code, 1, 1) IN ('4', '5')
            THEN
                Raise_Application_Error (-20000, g_reply (g_reply.LAST));
            ELSIF (    SUBSTR (g_reply (g_reply.LAST), 1, 3) = l_reply_code
                   AND SUBSTR (g_reply (g_reply.LAST), 4, 1) = ' ')
            THEN
                EXIT;
            END IF;
        END LOOP;
    EXCEPTION
        WHEN UTL_TCP.END_OF_INPUT
        THEN
            NULL;
    END;

------------------------------------------------------------------------------------------------------------------------
    FUNCTION Get_Local_Ascii_Data (
        p_dir                           IN      VARCHAR2,
        p_file                          IN      VARCHAR2)
        RETURN CLOB IS
------------------------------------------------------------------------------------------------------------------------
        l_bfile                         BFILE;
        l_data                          CLOB;
    BEGIN
        DBMS_LOB.createtemporary (lob_loc => l_data, CACHE => TRUE, dur => DBMS_LOB.CALL);
        l_bfile  := BFILENAME (p_dir, p_file);
        DBMS_LOB.fileopen (l_bfile, DBMS_LOB.file_readonly);

        IF DBMS_LOB.getlength (l_bfile) > 0
        THEN
            DBMS_LOB.loadfromfile (l_data, l_bfile, DBMS_LOB.getlength (l_bfile));
        END IF;

        DBMS_LOB.fileclose (l_bfile);
        RETURN l_data;
    END;

------------------------------------------------------------------------------------------------------------------------
    FUNCTION Get_Local_Binary_Data (
        p_dir                           IN      VARCHAR2,
        p_file                          IN      VARCHAR2)
        RETURN BLOB IS
------------------------------------------------------------------------------------------------------------------------
        l_bfile                         BFILE;
        l_data                          BLOB;
    BEGIN
        DBMS_LOB.createtemporary (lob_loc => l_data, CACHE => TRUE, dur => DBMS_LOB.CALL);
        l_bfile  := BFILENAME (p_dir, p_file);
        DBMS_LOB.fileopen (l_bfile, DBMS_LOB.file_readonly);

        IF DBMS_LOB.getlength (l_bfile) > 0
        THEN
            DBMS_LOB.loadfromfile (l_data, l_bfile, DBMS_LOB.getlength (l_bfile));
        END IF;

        DBMS_LOB.fileclose (l_bfile);
        RETURN l_data;
    END;

------------------------------------------------------------------------------------------------------------------------
    FUNCTION Get_Remote_Ascii_Data (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_file                          IN      VARCHAR2)
        RETURN CLOB IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_amount                        PLS_INTEGER;
        l_buffer                        VARCHAR2 (32767);
        l_data                          CLOB;
    BEGIN
        DBMS_LOB.createtemporary (lob_loc => l_data, CACHE => TRUE, dur => DBMS_LOB.CALL);
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'RETR ' || p_file, TRUE);

        BEGIN
            LOOP
                l_amount  := UTL_TCP.read_text (l_conn, l_buffer, 32767);
                DBMS_LOB.writeappend (l_data, l_amount, l_buffer);
            END LOOP;
        EXCEPTION
            WHEN UTL_TCP.END_OF_INPUT
            THEN
                NULL;
            WHEN OTHERS
            THEN
                NULL;
        END;

        UTL_TCP.close_connection (l_conn);
        get_reply (p_conn);
        RETURN l_data;
    EXCEPTION
        WHEN OTHERS
        THEN
            UTL_TCP.close_connection (l_conn);
            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    FUNCTION Get_Remote_Binary_Data (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_file                          IN      VARCHAR2)
        RETURN BLOB IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_amount                        PLS_INTEGER;
        l_buffer                        RAW (32767);
        l_data                          BLOB;
    BEGIN
        DBMS_LOB.createtemporary (lob_loc => l_data, CACHE => TRUE, dur => DBMS_LOB.CALL);
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'RETR ' || p_file, TRUE);

        BEGIN
            LOOP
                l_amount  := UTL_TCP.read_raw (l_conn, l_buffer, 32767);
                DBMS_LOB.writeappend (l_data, l_amount, l_buffer);
            END LOOP;
        EXCEPTION
            WHEN UTL_TCP.END_OF_INPUT
            THEN
                NULL;
            WHEN OTHERS
            THEN
                NULL;
        END;

        UTL_TCP.close_connection (l_conn);
        get_reply (p_conn);
        RETURN l_data;
    EXCEPTION
        WHEN OTHERS
        THEN
            UTL_TCP.close_connection (l_conn);
            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Put_Local_Ascii_Data (
        p_data                          IN      CLOB,
        p_dir                           IN      VARCHAR2,
        p_file                          IN      VARCHAR2) IS
------------------------------------------------------------------------------------------------------------------------
        l_out_file                      UTL_FILE.file_type;
        l_buffer                        VARCHAR2 (32767);
        l_amount                        BINARY_INTEGER := 32767;
        l_pos                           INTEGER := 1;
        l_clob_len                      INTEGER;
    BEGIN
        l_clob_len  := DBMS_LOB.getlength (p_data);
        l_out_file  := UTL_FILE.fopen (p_dir, p_file, 'w', 32767);

        WHILE l_pos <= l_clob_len
        LOOP
            DBMS_LOB.READ (p_data, l_amount, l_pos, l_buffer);

            IF g_convert_crlf
            THEN
                l_buffer  := REPLACE (l_buffer, CHR (13), NULL);
            END IF;

            UTL_FILE.put (l_out_file, l_buffer);
            UTL_FILE.fflush (l_out_file);
            l_pos  := l_pos + l_amount;
        END LOOP;

        UTL_FILE.fclose (l_out_file);
    EXCEPTION
        WHEN OTHERS
        THEN
            IF UTL_FILE.is_open (l_out_file)
            THEN
                UTL_FILE.fclose (l_out_file);
            END IF;

            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Put_Local_Binary_Data (
        p_data                          IN      BLOB,
        p_dir                           IN      VARCHAR2,
        p_file                          IN      VARCHAR2) IS
------------------------------------------------------------------------------------------------------------------------
        l_out_file                      UTL_FILE.file_type;
        l_buffer                        RAW (32767);
        l_amount                        BINARY_INTEGER := 32767;
        l_pos                           INTEGER := 1;
        l_blob_len                      INTEGER;
    BEGIN
        l_blob_len  := DBMS_LOB.getlength (p_data);
        l_out_file  := UTL_FILE.fopen (p_dir, p_file, 'wb', 32767);

        WHILE l_pos <= l_blob_len
        LOOP
            DBMS_LOB.READ (p_data, l_amount, l_pos, l_buffer);
            UTL_FILE.put_raw (l_out_file, l_buffer, TRUE);
            UTL_FILE.fflush (l_out_file);
            l_pos  := l_pos + l_amount;
        END LOOP;

        UTL_FILE.fclose (l_out_file);
    EXCEPTION
        WHEN OTHERS
        THEN
            IF UTL_FILE.is_open (l_out_file)
            THEN
                UTL_FILE.fclose (l_out_file);
            END IF;

            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Put_Remote_Ascii_Data (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_file                          IN      VARCHAR2,
        p_data                          IN      CLOB) IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_result                        PLS_INTEGER;
        l_buffer                        VARCHAR2 (32767);
        l_amount                        BINARY_INTEGER := 32767;
                                                -- Switch to 10000 (or use binary) if you get ORA-06502 from this line.
        l_pos                           INTEGER := 1;
        l_clob_len                      INTEGER;
    BEGIN
        l_conn      := get_passive (p_conn);
        send_command (p_conn, 'STOR ' || p_file, TRUE);
        l_clob_len  := DBMS_LOB.getlength (p_data);

        WHILE l_pos <= l_clob_len
        LOOP
            DBMS_LOB.READ (p_data, l_amount, l_pos, l_buffer);

            IF g_convert_crlf
            THEN
                l_buffer  := REPLACE (l_buffer, CHR (13), NULL);
            END IF;

            l_result  := UTL_TCP.write_text (l_conn, l_buffer, LENGTH (l_buffer));
            UTL_TCP.FLUSH (l_conn);
            l_pos     := l_pos + l_amount;
        END LOOP;

        UTL_TCP.close_connection (l_conn);
    -- The following line allows some people to make multiple calls from one connection.
    -- It causes the operation to hang for me, hence it is commented out by default.
    -- get_reply(p_conn);
    EXCEPTION
        WHEN OTHERS
        THEN
            UTL_TCP.close_connection (l_conn);
            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Put_Remote_Binary_Data (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_file                          IN      VARCHAR2,
        p_data                          IN      BLOB) IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_result                        PLS_INTEGER;
        l_buffer                        RAW (32767);
        l_amount                        BINARY_INTEGER := 32767;
        l_pos                           INTEGER := 1;
        l_blob_len                      INTEGER;
    BEGIN
        l_conn      := get_passive (p_conn);
        send_command (p_conn, 'STOR ' || p_file, TRUE);
        l_blob_len  := DBMS_LOB.getlength (p_data);

        WHILE l_pos <= l_blob_len
        LOOP
            DBMS_LOB.READ (p_data, l_amount, l_pos, l_buffer);
            l_result  := UTL_TCP.write_raw (l_conn, l_buffer, l_amount);
            UTL_TCP.FLUSH (l_conn);
            l_pos     := l_pos + l_amount;
        END LOOP;

        UTL_TCP.close_connection (l_conn);
    -- The following line allows some people to make multiple calls from one connection.
    -- It causes the operation to hang for me, hence it is commented out by default.
    -- get_reply(p_conn);
    EXCEPTION
        WHEN OTHERS
        THEN
            UTL_TCP.close_connection (l_conn);
            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Get (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_from_file                     IN      VARCHAR2,
        p_to_dir                        IN      VARCHAR2,
        p_to_file                       IN      VARCHAR2) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        IF g_binary
        THEN
            put_local_binary_data (p_data     => get_remote_binary_data (p_conn, p_from_file),
                                   p_dir      => p_to_dir,
                                   p_file     => p_to_file);
        ELSE
            put_local_ascii_data (p_data     => get_remote_ascii_data (p_conn, p_from_file),
                                  p_dir      => p_to_dir,
                                  p_file     => p_to_file);
        END IF;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Put (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_from_dir                      IN      VARCHAR2,
        p_from_file                     IN      VARCHAR2,
        p_to_file                       IN      VARCHAR2) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        IF g_binary
        THEN
            put_remote_binary_data (p_conn     => p_conn,
                                    p_file     => p_to_file,
                                    p_data     => get_local_binary_data (p_from_dir, p_from_file));
        ELSE
            put_remote_ascii_data (p_conn     => p_conn,
                                   p_file     => p_to_file,
                                   p_data     => get_local_ascii_data (p_from_dir, p_from_file));
        END IF;

        get_reply (p_conn);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Get_Direct (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_from_file                     IN      VARCHAR2,
        p_to_dir                        IN      VARCHAR2,
        p_to_file                       IN      VARCHAR2) IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_out_file                      UTL_FILE.file_type;
        l_amount                        PLS_INTEGER;
        l_buffer                        VARCHAR2 (32767);
        l_raw_buffer                    RAW (32767);
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'RETR ' || p_from_file, TRUE);

        IF g_binary
        THEN
            l_out_file  := UTL_FILE.fopen (p_to_dir, p_to_file, 'wb', 32767);
        ELSE
            l_out_file  := UTL_FILE.fopen (p_to_dir, p_to_file, 'w', 32767);
        END IF;

        BEGIN
            LOOP
                IF g_binary
                THEN
                    l_amount  := UTL_TCP.read_raw (l_conn, l_raw_buffer, 32767);
                    UTL_FILE.put_raw (l_out_file, l_raw_buffer, TRUE);
                ELSE
                    l_amount  := UTL_TCP.read_text (l_conn, l_buffer, 32767);

                    IF g_convert_crlf
                    THEN
                        l_buffer  := REPLACE (l_buffer, CHR (13), NULL);
                    END IF;

                    UTL_FILE.put (l_out_file, l_buffer);
                END IF;

                UTL_FILE.fflush (l_out_file);
            END LOOP;
        EXCEPTION
            WHEN UTL_TCP.END_OF_INPUT
            THEN
                NULL;
            WHEN OTHERS
            THEN
                NULL;
        END;

        UTL_FILE.fclose (l_out_file);
        UTL_TCP.close_connection (l_conn);
    EXCEPTION
        WHEN OTHERS
        THEN
            IF UTL_FILE.is_open (l_out_file)
            THEN
                UTL_FILE.fclose (l_out_file);
            END IF;

            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Put_Direct (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_from_dir                      IN      VARCHAR2,
        p_from_file                     IN      VARCHAR2,
        p_to_file                       IN      VARCHAR2) IS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_bfile                         BFILE;
        l_result                        PLS_INTEGER;
        l_amount                        PLS_INTEGER := 32767;
        l_raw_buffer                    RAW (32767);
        l_len                           NUMBER;
        l_pos                           NUMBER := 1;
        ex_ascii                        EXCEPTION;
    BEGIN
        IF NOT g_binary
        THEN
            RAISE ex_ascii;
        END IF;

        l_conn   := get_passive (p_conn);
        send_command (p_conn, 'STOR ' || p_to_file, TRUE);
        l_bfile  := BFILENAME (p_from_dir, p_from_file);
        DBMS_LOB.fileopen (l_bfile, DBMS_LOB.file_readonly);
        l_len    := DBMS_LOB.getlength (l_bfile);

        WHILE l_pos <= l_len
        LOOP
            DBMS_LOB.READ (l_bfile, l_amount, l_pos, l_raw_buffer);
            DEBUG (l_amount);
            l_result  := UTL_TCP.write_raw (l_conn, l_raw_buffer, l_amount);
            l_pos     := l_pos + l_amount;
        END LOOP;

        DBMS_LOB.fileclose (l_bfile);
        UTL_TCP.close_connection (l_conn);
    EXCEPTION
        WHEN ex_ascii
        THEN
            Raise_Application_Error (-20000, 'PUT_DIRECT not available in ASCII mode.');
        WHEN OTHERS
        THEN
            IF DBMS_LOB.fileisopen (l_bfile) = 1
            THEN
                DBMS_LOB.fileclose (l_bfile);
            END IF;

            RAISE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE HELP (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        send_command (p_conn, 'HELP', TRUE);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE ASCII (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        send_command (p_conn, 'TYPE A', TRUE);
        g_binary  := FALSE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE BINARY (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        send_command (p_conn, 'TYPE I', TRUE);
        g_binary  := TRUE;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE LIST (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_dir                           IN      VARCHAR2,
        p_list                          OUT     t_string_table) AS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_list                          t_string_table := t_string_table ();
        l_reply_code                    VARCHAR2 (3) := NULL;
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'LIST ' || p_dir, TRUE);

        BEGIN
            LOOP
                l_list.EXTEND;
                l_list (l_list.LAST)  := UTL_TCP.get_line (l_conn, TRUE);
                DEBUG (l_list (l_list.LAST));

                IF l_reply_code IS NULL
                THEN
                    l_reply_code  := SUBSTR (l_list (l_list.LAST), 1, 3);
                END IF;

                IF (    SUBSTR (l_reply_code, 1, 1) IN ('4', '5')
                    AND SUBSTR (l_reply_code, 4, 1) = ' ')
                THEN
                    Raise_Application_Error (-20000, l_list (l_list.LAST));
                ELSIF (    SUBSTR (g_reply (g_reply.LAST), 1, 3) = l_reply_code
                       AND SUBSTR (g_reply (g_reply.LAST), 4, 1) = ' ')
                THEN
                    EXIT;
                END IF;
            END LOOP;
        EXCEPTION
            WHEN UTL_TCP.END_OF_INPUT
            THEN
                NULL;
        END;

        l_list.DELETE (l_list.LAST);
        p_list  := l_list;
        UTL_TCP.close_connection (l_conn);
        get_reply (p_conn);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Nlst (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_dir                           IN      VARCHAR2,
        p_list                          OUT     t_string_table) AS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
        l_list                          t_string_table := t_string_table ();
        l_reply_code                    VARCHAR2 (3) := NULL;
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'NLST ' || p_dir, TRUE);

        BEGIN
            LOOP
                l_list.EXTEND;
                l_list (l_list.LAST)  := UTL_TCP.get_line (l_conn, TRUE);
                DEBUG (l_list (l_list.LAST));

                IF l_reply_code IS NULL
                THEN
                    l_reply_code  := SUBSTR (l_list (l_list.LAST), 1, 3);
                END IF;

                IF (    SUBSTR (l_reply_code, 1, 1) IN ('4', '5')
                    AND SUBSTR (l_reply_code, 4, 1) = ' ')
                THEN
                    Raise_Application_Error (-20000, l_list (l_list.LAST));
                ELSIF (    SUBSTR (g_reply (g_reply.LAST), 1, 3) = l_reply_code
                       AND SUBSTR (g_reply (g_reply.LAST), 4, 1) = ' ')
                THEN
                    EXIT;
                END IF;
            END LOOP;
        EXCEPTION
            WHEN UTL_TCP.END_OF_INPUT
            THEN
                NULL;
        END;

        l_list.DELETE (l_list.LAST);
        p_list  := l_list;
        UTL_TCP.close_connection (l_conn);
        get_reply (p_conn);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE RENAME (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_from                          IN      VARCHAR2,
        p_to                            IN      VARCHAR2) AS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'RNFR ' || p_from, TRUE);
        send_command (p_conn, 'RNTO ' || p_to, TRUE);
        LOGOUT (l_conn, FALSE);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE DELETE (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_file                          IN      VARCHAR2) AS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'DELE ' || p_file, TRUE);
        LOGOUT (l_conn, FALSE);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Mkdir (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_dir                           IN      VARCHAR2) AS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'MKD ' || p_dir, TRUE);
        LOGOUT (l_conn, FALSE);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Rmdir (
        p_conn                          IN OUT NOCOPY UTL_TCP.connection,
        p_dir                           IN      VARCHAR2) AS
------------------------------------------------------------------------------------------------------------------------
        l_conn                          UTL_TCP.connection;
    BEGIN
        l_conn  := get_passive (p_conn);
        send_command (p_conn, 'RMD ' || p_dir, TRUE);
        LOGOUT (l_conn, FALSE);
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE Convert_Crlf (
        p_status                        IN      BOOLEAN) AS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        g_convert_crlf  := p_status;
    END;

------------------------------------------------------------------------------------------------------------------------
    PROCEDURE DEBUG (
        p_text                          IN      VARCHAR2) IS
------------------------------------------------------------------------------------------------------------------------
    BEGIN
        IF g_debug
        THEN
            DBMS_OUTPUT.put_line (SUBSTR (p_text, 1, 255));
        END IF;
    END;
------------------------------------------------------------------------------------------------------------------------
END;
/
